---
// Add whatever props you like for customization
const SIM_RESOLUTION = 128;
const DYE_RESOLUTION = 1440;
const CAPTURE_RESOLUTION = 512;
const DENSITY_DISSIPATION = 3.5;
const VELOCITY_DISSIPATION = 2;
const PRESSURE = 0.1;
const PRESSURE_ITERATIONS = 20;
const CURL = 5;
const SPLAT_RADIUS = 0.2;
const SPLAT_FORCE = 6000;
const SHADING = true;
const COLOR_UPDATE_SPEED = 10;
const BACK_COLOR = { r: 0.5, g: 0, b: 0 };
const TRANSPARENT = true;
---

<splash-cursor>
  <div class="fixed top-0 left-0 z-50 pointer-events-none w-full h-full">
    <canvas
      id="fluid"
      class="canvas-spash-cursor w-screen h-screen block"
      data-simResolution={SIM_RESOLUTION}
      data-dyeResolution={DYE_RESOLUTION}
      data-captureResolution={CAPTURE_RESOLUTION}
      data-densityDissipation={DENSITY_DISSIPATION}
      data-velocityDissipation={VELOCITY_DISSIPATION}
      data-pressure={PRESSURE}
      data-pressureIterations={PRESSURE_ITERATIONS}
      data-curl={CURL}
      data-splatRadius={SPLAT_RADIUS}
      data-splatForce={SPLAT_FORCE}
      data-shading={SHADING}
      data-colorUpdateSpeed={COLOR_UPDATE_SPEED}
      data-backColor={BACK_COLOR}
      data-transparent={TRANSPARENT}></canvas>
  </div>
</splash-cursor>

<script>
  const hashCode = (s: String) => {
    if (s.length === 0) return 0;
    let hash = 0;
    for (let i = 0; i < s.length; i++) {
      hash = (hash << 5) - hash + s.charCodeAt(i);
      hash |= 0;
    }
    return hash;
  };

  const createProgram = (gl, vertexShader, fragmentShader) => {
    let program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS))
      console.trace(gl.getProgramInfoLog(program));
    return program;
  };

  const getUniforms = (gl, program) => {
    let uniforms = [];
    let uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < uniformCount; i++) {
      let uniformName = gl.getActiveUniform(program, i).name;
      uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
    }
    return uniforms;
  };

  const compileShader = (gl, type, source, keywords) => {
    source = addKeywords(source, keywords);
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
      console.trace(gl.getShaderInfoLog(shader));
    return shader;
  };

  class Material {
    constructor(gl, vertexShader, fragmentShaderSource) {
      this.gl = gl;
      this.vertexShader = vertexShader;
      this.fragmentShaderSource = fragmentShaderSource;
      this.programs = [];
      this.activeProgram = null;
      this.uniforms = [];
    }
    setKeywords(keywords) {
      let hash = 0;
      for (let i = 0; i < keywords.length; i++) hash += hashCode(keywords[i]);
      let program = this.programs[hash];
      if (program == null) {
        let fragmentShader = compileShader(
          this.gl,
          this.gl.FRAGMENT_SHADER,
          this.fragmentShaderSource,
          keywords
        );
        program = createProgram(this.gl, this.vertexShader, fragmentShader);
        this.programs[hash] = program;
      }
      if (program === this.activeProgram) return;
      this.uniforms = getUniforms(this.gl, program);
      this.activeProgram = program;
    }
    bind() {
      this.gl.useProgram(this.activeProgram);
    }
  }

  class Program {
    constructor(gl, vertexShader, fragmentShader) {
      this.gl = gl;
      this.uniforms = {};
      this.program = createProgram(this.gl, vertexShader, fragmentShader);
      this.uniforms = getUniforms(this.gl, this.program);
    }
    bind() {
      this.gl.useProgram(this.program);
    }
  }

  class PointerPrototype {
    constructor() {
      this.id = -1;
      this.texcoordX = 0;
      this.texcoordY = 0;
      this.prevTexcoordX = 0;
      this.prevTexcoordY = 0;
      this.deltaX = 0;
      this.deltaY = 0;
      this.down = false;
      this.moved = false;
      this.color = [0, 0, 0];
    }
  }

  const addKeywords = (source, keywords) => {
    if (!keywords) return source;
    let keywordsString = "";
    keywords.forEach((keyword) => {
      keywordsString += "#define " + keyword + "\n";
    });
    return keywordsString + source;
  };

  class SplashCursor extends HTMLElement {
    canvas = this.querySelector(".canvas-spash-cursor") as HTMLElement;

    config = {
      SIM_RESOLUTION: this.canvas.dataset.simresolution,
      DYE_RESOLUTION: this.canvas.dataset.dyeresolution,
      CAPTURE_RESOLUTION: this.canvas.dataset.captureresolution,
      DENSITY_DISSIPATION: this.canvas.dataset.densitydissipation,
      VELOCITY_DISSIPATION: this.canvas.dataset.velocitydissipation,
      PRESSURE: this.canvas.dataset.pressure,
      PRESSURE_ITERATIONS: this.canvas.dataset.pressureiterations,
      CURL: this.canvas.dataset.curl,
      SPLAT_RADIUS: this.canvas.dataset.splatradius,
      SPLAT_FORCE: this.canvas.dataset.splatforce,
      SHADING: this.canvas.dataset.shading,
      COLOR_UPDATE_SPEED: this.canvas.dataset.colorupdatespeed,
      PAUSED: false,
      BACK_COLOR: this.canvas.dataset.backcolor,
      TRANSPARENT: this.canvas.dataset.transparent,
    };

    getWebGLContext(canvas) {
      const params = {
        alpha: true,
        depth: false,
        stencil: false,
        antialias: false,
        preserveDrawingBuffer: false,
      };
      let gl = canvas.getContext("webgl2", params);
      const isWebGL2 = !!gl;
      if (!isWebGL2)
        gl =
          canvas.getContext("webgl", params) ||
          canvas.getContext("experimental-webgl", params);
      let halfFloat;
      let supportLinearFiltering;
      if (isWebGL2) {
        gl.getExtension("EXT_color_buffer_float");
        supportLinearFiltering = gl.getExtension("OES_texture_float_linear");
      } else {
        halfFloat = gl.getExtension("OES_texture_half_float");
        supportLinearFiltering = gl.getExtension(
          "OES_texture_half_float_linear"
        );
      }
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      const halfFloatTexType = isWebGL2
        ? gl.HALF_FLOAT
        : halfFloat && halfFloat.HALF_FLOAT_OES;
      let formatRGBA;
      let formatRG;
      let formatR;

      if (isWebGL2) {
        formatRGBA = this.getSupportedFormat(
          gl,
          gl.RGBA16F,
          gl.RGBA,
          halfFloatTexType
        );
        formatRG = this.getSupportedFormat(
          gl,
          gl.RG16F,
          gl.RG,
          halfFloatTexType
        );
        formatR = this.getSupportedFormat(
          gl,
          gl.R16F,
          gl.RED,
          halfFloatTexType
        );
      } else {
        formatRGBA = this.getSupportedFormat(
          gl,
          gl.RGBA,
          gl.RGBA,
          halfFloatTexType
        );
        formatRG = this.getSupportedFormat(
          gl,
          gl.RGBA,
          gl.RGBA,
          halfFloatTexType
        );
        formatR = this.getSupportedFormat(
          gl,
          gl.RGBA,
          gl.RGBA,
          halfFloatTexType
        );
      }

      return {
        gl,
        ext: {
          formatRGBA,
          formatRG,
          formatR,
          halfFloatTexType,
          supportLinearFiltering,
        },
      };
    }

    getSupportedFormat(gl, internalFormat, format, type) {
      if (!this.supportRenderTextureFormat(gl, internalFormat, format, type)) {
        switch (internalFormat) {
          case gl.R16F:
            return this.getSupportedFormat(gl, gl.RG16F, gl.RG, type);
          case gl.RG16F:
            return this.getSupportedFormat(gl, gl.RGBA16F, gl.RGBA, type);
          default:
            return null;
        }
      }
      return {
        internalFormat,
        format,
      };
    }

    supportRenderTextureFormat(gl, internalFormat, format, type) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        internalFormat,
        4,
        4,
        0,
        format,
        type,
        null
      );
      const fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        texture,
        0
      );
      const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      return status === gl.FRAMEBUFFER_COMPLETE;
    }

    connectedCallback() {
      // const canvas = this.querySelector(".canvas-spash-cursor");
      if (!this.canvas) return;

      let pointers = [new PointerPrototype()];

      const { gl, ext } = this.getWebGLContext(this.canvas);

      if (!ext.supportLinearFiltering) {
        this.config.DYE_RESOLUTION = 256;
        this.config.SHADING = false;
      }

      const getResolution = (resolution) => {
        let aspectRatio = gl.drawingBufferWidth / gl.drawingBufferHeight;
        if (aspectRatio < 1) aspectRatio = 1.0 / aspectRatio;
        const min = Math.round(resolution);
        const max = Math.round(resolution * aspectRatio);
        if (gl.drawingBufferWidth > gl.drawingBufferHeight)
          return { width: max, height: min };
        else return { width: min, height: max };
      };

      const baseVertexShader = compileShader(
        gl,
        gl.VERTEX_SHADER,
        `
        precision highp float;
        attribute vec2 aPosition;
        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;
        uniform vec2 texelSize;

        void main () {
            vUv = aPosition * 0.5 + 0.5;
            vL = vUv - vec2(texelSize.x, 0.0);
            vR = vUv + vec2(texelSize.x, 0.0);
            vT = vUv + vec2(0.0, texelSize.y);
            vB = vUv - vec2(0.0, texelSize.y);
            gl_Position = vec4(aPosition, 0.0, 1.0);
        }
      `
      );

      const copyShader = compileShader(
        gl,
        gl.FRAGMENT_SHADER,
        `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        uniform sampler2D uTexture;

        void main () {
            gl_FragColor = texture2D(uTexture, vUv);
        }
      `
      );

      const clearShader = compileShader(
        gl,
        gl.FRAGMENT_SHADER,
        `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        uniform sampler2D uTexture;
        uniform float value;

        void main () {
            gl_FragColor = value * texture2D(uTexture, vUv);
        }
     `
      );

      const displayShaderSource = `
      precision highp float;
      precision highp sampler2D;
      varying vec2 vUv;
      varying vec2 vL;
      varying vec2 vR;
      varying vec2 vT;
      varying vec2 vB;
      uniform sampler2D uTexture;
      uniform sampler2D uDithering;
      uniform vec2 ditherScale;
      uniform vec2 texelSize;

      vec3 linearToGamma (vec3 color) {
          color = max(color, vec3(0));
          return max(1.055 * pow(color, vec3(0.416666667)) - 0.055, vec3(0));
      }

      void main () {
          vec3 c = texture2D(uTexture, vUv).rgb;
          #ifdef SHADING
              vec3 lc = texture2D(uTexture, vL).rgb;
              vec3 rc = texture2D(uTexture, vR).rgb;
              vec3 tc = texture2D(uTexture, vT).rgb;
              vec3 bc = texture2D(uTexture, vB).rgb;

              float dx = length(rc) - length(lc);
              float dy = length(tc) - length(bc);

              vec3 n = normalize(vec3(dx, dy, length(texelSize)));
              vec3 l = vec3(0.0, 0.0, 1.0);

              float diffuse = clamp(dot(n, l) + 0.7, 0.7, 1.0);
              c *= diffuse;
          #endif

          float a = max(c.r, max(c.g, c.b));
          gl_FragColor = vec4(c, a);
      }
    `;

      const splatShader = compileShader(
        gl,
        gl.FRAGMENT_SHADER,
        `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        uniform sampler2D uTarget;
        uniform float aspectRatio;
        uniform vec3 color;
        uniform vec2 point;
        uniform float radius;

        void main () {
            vec2 p = vUv - point.xy;
            p.x *= aspectRatio;
            vec3 splat = exp(-dot(p, p) / radius) * color;
            vec3 base = texture2D(uTarget, vUv).xyz;
            gl_FragColor = vec4(base + splat, 1.0);
        }
      `
      );

      const advectionShader = compileShader(
        gl,
        gl.FRAGMENT_SHADER,
        `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        uniform sampler2D uVelocity;
        uniform sampler2D uSource;
        uniform vec2 texelSize;
        uniform vec2 dyeTexelSize;
        uniform float dt;
        uniform float dissipation;

        vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {
            vec2 st = uv / tsize - 0.5;
            vec2 iuv = floor(st);
            vec2 fuv = fract(st);

            vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);
            vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);
            vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);
            vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);

            return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);
        }

        void main () {
            #ifdef MANUAL_FILTERING
                vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;
                vec4 result = bilerp(uSource, coord, dyeTexelSize);
            #else
                vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;
                vec4 result = texture2D(uSource, coord);
            #endif
            float decay = 1.0 + dissipation * dt;
            gl_FragColor = result / decay;
        }
      `,
        ext.supportLinearFiltering ? null : ["MANUAL_FILTERING"]
      );

      const divergenceShader = compileShader(
        gl,
        gl.FRAGMENT_SHADER,
        `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uVelocity;

        void main () {
            float L = texture2D(uVelocity, vL).x;
            float R = texture2D(uVelocity, vR).x;
            float T = texture2D(uVelocity, vT).y;
            float B = texture2D(uVelocity, vB).y;

            vec2 C = texture2D(uVelocity, vUv).xy;
            if (vL.x < 0.0) { L = -C.x; }
            if (vR.x > 1.0) { R = -C.x; }
            if (vT.y > 1.0) { T = -C.y; }
            if (vB.y < 0.0) { B = -C.y; }

            float div = 0.5 * (R - L + T - B);
            gl_FragColor = vec4(div, 0.0, 0.0, 1.0);
        }
      `
      );

      const curlShader = compileShader(
        gl,
        gl.FRAGMENT_SHADER,
        `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uVelocity;

        void main () {
            float L = texture2D(uVelocity, vL).y;
            float R = texture2D(uVelocity, vR).y;
            float T = texture2D(uVelocity, vT).x;
            float B = texture2D(uVelocity, vB).x;
            float vorticity = R - L - T + B;
            gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);
        }
      `
      );

      const vorticityShader = compileShader(
        gl,
        gl.FRAGMENT_SHADER,
        `
        precision highp float;
        precision highp sampler2D;
        varying vec2 vUv;
        varying vec2 vL;
        varying vec2 vR;
        varying vec2 vT;
        varying vec2 vB;
        uniform sampler2D uVelocity;
        uniform sampler2D uCurl;
        uniform float curl;
        uniform float dt;

        void main () {
            float L = texture2D(uCurl, vL).x;
            float R = texture2D(uCurl, vR).x;
            float T = texture2D(uCurl, vT).x;
            float B = texture2D(uCurl, vB).x;
            float C = texture2D(uCurl, vUv).x;

            vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));
            force /= length(force) + 0.0001;
            force *= curl * C;
            force.y *= -1.0;

            vec2 velocity = texture2D(uVelocity, vUv).xy;
            velocity += force * dt;
            velocity = min(max(velocity, -1000.0), 1000.0);
            gl_FragColor = vec4(velocity, 0.0, 1.0);
        }
      `
      );

      const pressureShader = compileShader(
        gl,
        gl.FRAGMENT_SHADER,
        `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uPressure;
        uniform sampler2D uDivergence;

        void main () {
            float L = texture2D(uPressure, vL).x;
            float R = texture2D(uPressure, vR).x;
            float T = texture2D(uPressure, vT).x;
            float B = texture2D(uPressure, vB).x;
            float C = texture2D(uPressure, vUv).x;
            float divergence = texture2D(uDivergence, vUv).x;
            float pressure = (L + R + B + T - divergence) * 0.25;
            gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);
        }
      `
      );

      const gradientSubtractShader = compileShader(
        gl,
        gl.FRAGMENT_SHADER,
        `
        precision mediump float;
        precision mediump sampler2D;
        varying highp vec2 vUv;
        varying highp vec2 vL;
        varying highp vec2 vR;
        varying highp vec2 vT;
        varying highp vec2 vB;
        uniform sampler2D uPressure;
        uniform sampler2D uVelocity;

        void main () {
            float L = texture2D(uPressure, vL).x;
            float R = texture2D(uPressure, vR).x;
            float T = texture2D(uPressure, vT).x;
            float B = texture2D(uPressure, vB).x;
            vec2 velocity = texture2D(uVelocity, vUv).xy;
            velocity.xy -= vec2(R - L, T - B);
            gl_FragColor = vec4(velocity, 0.0, 1.0);
        }
      `
      );

      const blit = (() => {
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]),
          gl.STATIC_DRAW
        );
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array([0, 1, 2, 0, 2, 3]),
          gl.STATIC_DRAW
        );
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(0);
        return (target, clear = false) => {
          if (target == null) {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          } else {
            gl.viewport(0, 0, target.width, target.height);
            gl.bindFramebuffer(gl.FRAMEBUFFER, target.fbo);
          }
          if (clear) {
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
          }
          gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
        };
      })();

      let dye, velocity, divergence, curl, pressure;

      const copyProgram = new Program(gl, baseVertexShader, copyShader);
      const clearProgram = new Program(gl, baseVertexShader, clearShader);
      const splatProgram = new Program(gl, baseVertexShader, splatShader);
      const advectionProgram = new Program(
        gl,
        baseVertexShader,
        advectionShader
      );
      const divergenceProgram = new Program(
        gl,
        baseVertexShader,
        divergenceShader
      );
      const curlProgram = new Program(gl, baseVertexShader, curlShader);
      const vorticityProgram = new Program(
        gl,
        baseVertexShader,
        vorticityShader
      );
      const pressureProgram = new Program(gl, baseVertexShader, pressureShader);
      const gradienSubtractProgram = new Program(
        gl,
        baseVertexShader,
        gradientSubtractShader
      );
      const displayMaterial = new Material(
        gl,
        baseVertexShader,
        displayShaderSource
      );

      const initFramebuffers = () => {
        let simRes = getResolution(this.config.SIM_RESOLUTION);
        let dyeRes = getResolution(this.config.DYE_RESOLUTION);
        const texType = ext.halfFloatTexType;
        const rgba = ext.formatRGBA;
        const rg = ext.formatRG;
        const r = ext.formatR;
        const filtering = ext.supportLinearFiltering ? gl.LINEAR : gl.NEAREST;
        gl.disable(gl.BLEND);

        if (!dye)
          dye = createDoubleFBO(
            dyeRes.width,
            dyeRes.height,
            rgba.internalFormat,
            rgba.format,
            texType,
            filtering
          );
        else
          dye = resizeDoubleFBO(
            dye,
            dyeRes.width,
            dyeRes.height,
            rgba.internalFormat,
            rgba.format,
            texType,
            filtering
          );

        if (!velocity)
          velocity = createDoubleFBO(
            simRes.width,
            simRes.height,
            rg.internalFormat,
            rg.format,
            texType,
            filtering
          );
        else
          velocity = resizeDoubleFBO(
            velocity,
            simRes.width,
            simRes.height,
            rg.internalFormat,
            rg.format,
            texType,
            filtering
          );

        divergence = createFBO(
          simRes.width,
          simRes.height,
          r.internalFormat,
          r.format,
          texType,
          gl.NEAREST
        );
        curl = createFBO(
          simRes.width,
          simRes.height,
          r.internalFormat,
          r.format,
          texType,
          gl.NEAREST
        );
        pressure = createDoubleFBO(
          simRes.width,
          simRes.height,
          r.internalFormat,
          r.format,
          texType,
          gl.NEAREST
        );
      };

      const createFBO = (w, h, internalFormat, format, type, param) => {
        gl.activeTexture(gl.TEXTURE0);
        let texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, param);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, param);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          internalFormat,
          w,
          h,
          0,
          format,
          type,
          null
        );

        let fbo = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          texture,
          0
        );
        gl.viewport(0, 0, w, h);
        gl.clear(gl.COLOR_BUFFER_BIT);

        let texelSizeX = 1.0 / w;
        let texelSizeY = 1.0 / h;
        return {
          texture,
          fbo,
          width: w,
          height: h,
          texelSizeX,
          texelSizeY,
          attach(id) {
            gl.activeTexture(gl.TEXTURE0 + id);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            return id;
          },
        };
      };

      const createDoubleFBO = (w, h, internalFormat, format, type, param) => {
        let fbo1 = createFBO(w, h, internalFormat, format, type, param);
        let fbo2 = createFBO(w, h, internalFormat, format, type, param);
        return {
          width: w,
          height: h,
          texelSizeX: fbo1.texelSizeX,
          texelSizeY: fbo1.texelSizeY,
          get read() {
            return fbo1;
          },
          set read(value) {
            fbo1 = value;
          },
          get write() {
            return fbo2;
          },
          set write(value) {
            fbo2 = value;
          },
          swap() {
            let temp = fbo1;
            fbo1 = fbo2;
            fbo2 = temp;
          },
        };
      };

      const resizeFBO = (target, w, h, internalFormat, format, type, param) => {
        let newFBO = createFBO(w, h, internalFormat, format, type, param);
        copyProgram.bind();
        gl.uniform1i(copyProgram.uniforms.uTexture, target.attach(0));
        blit(newFBO);
        return newFBO;
      };

      const resizeDoubleFBO = (
        target,
        w,
        h,
        internalFormat,
        format,
        type,
        param
      ) => {
        if (target.width === w && target.height === h) return target;
        target.read = resizeFBO(
          target.read,
          w,
          h,
          internalFormat,
          format,
          type,
          param
        );
        target.write = createFBO(w, h, internalFormat, format, type, param);
        target.width = w;
        target.height = h;
        target.texelSizeX = 1.0 / w;
        target.texelSizeY = 1.0 / h;
        return target;
      };

      const updateKeywords = () => {
        let displayKeywords = [];
        if (this.config.SHADING) displayKeywords.push("SHADING");
        displayMaterial.setKeywords(displayKeywords);
      };

      updateKeywords();
      initFramebuffers();
      let lastUpdateTime = Date.now();
      let colorUpdateTimer = 0.0;

      const updateFrame = () => {
        const dt = calcDeltaTime();
        if (resizeCanvas()) initFramebuffers();
        updateColors(dt);
        applyInputs();
        step(dt);
        render(null);
        requestAnimationFrame(updateFrame);
      };

      const calcDeltaTime = () => {
        let now = Date.now();
        let dt = (now - lastUpdateTime) / 1000;
        dt = Math.min(dt, 0.016666);
        lastUpdateTime = now;
        return dt;
      };

      const resizeCanvas = () => {
        let width = scaleByPixelRatio(this.canvas.clientWidth);
        let height = scaleByPixelRatio(this.canvas.clientHeight);
        if (this.canvas.width !== width || this.canvas.height !== height) {
          this.canvas.width = width;
          this.canvas.height = height;
          return true;
        }
        return false;
      };

      const updateColors = (dt) => {
        colorUpdateTimer += dt * this.config.COLOR_UPDATE_SPEED;
        if (colorUpdateTimer >= 1) {
          colorUpdateTimer = wrap(colorUpdateTimer, 0, 1);
          pointers.forEach((p) => {
            p.color = generateColor();
          });
        }
      };

      const applyInputs = () => {
        pointers.forEach((p) => {
          if (p.moved) {
            p.moved = false;
            splatPointer(p);
          }
        });
      };

      const step = (dt) => {
        gl.disable(gl.BLEND);
        // Curl
        curlProgram.bind();
        gl.uniform2f(
          curlProgram.uniforms.texelSize,
          velocity.texelSizeX,
          velocity.texelSizeY
        );
        gl.uniform1i(curlProgram.uniforms.uVelocity, velocity.read.attach(0));
        blit(curl);

        // Vorticity
        vorticityProgram.bind();
        gl.uniform2f(
          vorticityProgram.uniforms.texelSize,
          velocity.texelSizeX,
          velocity.texelSizeY
        );
        gl.uniform1i(
          vorticityProgram.uniforms.uVelocity,
          velocity.read.attach(0)
        );
        gl.uniform1i(vorticityProgram.uniforms.uCurl, curl.attach(1));
        gl.uniform1f(vorticityProgram.uniforms.curl, this.config.CURL);
        gl.uniform1f(vorticityProgram.uniforms.dt, dt);
        blit(velocity.write);
        velocity.swap();

        // Divergence
        divergenceProgram.bind();
        gl.uniform2f(
          divergenceProgram.uniforms.texelSize,
          velocity.texelSizeX,
          velocity.texelSizeY
        );
        gl.uniform1i(
          divergenceProgram.uniforms.uVelocity,
          velocity.read.attach(0)
        );
        blit(divergence);

        // Clear pressure
        clearProgram.bind();
        gl.uniform1i(clearProgram.uniforms.uTexture, pressure.read.attach(0));
        gl.uniform1f(clearProgram.uniforms.value, this.config.PRESSURE);
        blit(pressure.write);
        pressure.swap();

        // Pressure
        pressureProgram.bind();
        gl.uniform2f(
          pressureProgram.uniforms.texelSize,
          velocity.texelSizeX,
          velocity.texelSizeY
        );
        gl.uniform1i(
          pressureProgram.uniforms.uDivergence,
          divergence.attach(0)
        );
        for (let i = 0; i < this.config.PRESSURE_ITERATIONS; i++) {
          gl.uniform1i(
            pressureProgram.uniforms.uPressure,
            pressure.read.attach(1)
          );
          blit(pressure.write);
          pressure.swap();
        }

        // Gradient Subtract
        gradienSubtractProgram.bind();
        gl.uniform2f(
          gradienSubtractProgram.uniforms.texelSize,
          velocity.texelSizeX,
          velocity.texelSizeY
        );
        gl.uniform1i(
          gradienSubtractProgram.uniforms.uPressure,
          pressure.read.attach(0)
        );
        gl.uniform1i(
          gradienSubtractProgram.uniforms.uVelocity,
          velocity.read.attach(1)
        );
        blit(velocity.write);
        velocity.swap();

        // Advection
        advectionProgram.bind();
        gl.uniform2f(
          advectionProgram.uniforms.texelSize,
          velocity.texelSizeX,
          velocity.texelSizeY
        );
        if (!ext.supportLinearFiltering)
          gl.uniform2f(
            advectionProgram.uniforms.dyeTexelSize,
            velocity.texelSizeX,
            velocity.texelSizeY
          );
        let velocityId = velocity.read.attach(0);
        gl.uniform1i(advectionProgram.uniforms.uVelocity, velocityId);
        gl.uniform1i(advectionProgram.uniforms.uSource, velocityId);
        gl.uniform1f(advectionProgram.uniforms.dt, dt);
        gl.uniform1f(
          advectionProgram.uniforms.dissipation,
          this.config.VELOCITY_DISSIPATION
        );
        blit(velocity.write);
        velocity.swap();

        if (!ext.supportLinearFiltering)
          gl.uniform2f(
            advectionProgram.uniforms.dyeTexelSize,
            dye.texelSizeX,
            dye.texelSizeY
          );
        gl.uniform1i(
          advectionProgram.uniforms.uVelocity,
          velocity.read.attach(0)
        );
        gl.uniform1i(advectionProgram.uniforms.uSource, dye.read.attach(1));
        gl.uniform1f(
          advectionProgram.uniforms.dissipation,
          this.config.DENSITY_DISSIPATION
        );
        blit(dye.write);
        dye.swap();
      };

      const render = (target) => {
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        drawDisplay(target);
      };

      const drawDisplay = (target) => {
        let width = target == null ? gl.drawingBufferWidth : target.width;
        let height = target == null ? gl.drawingBufferHeight : target.height;
        displayMaterial.bind();
        if (this.config.SHADING)
          gl.uniform2f(
            displayMaterial.uniforms.texelSize,
            1.0 / width,
            1.0 / height
          );
        gl.uniform1i(displayMaterial.uniforms.uTexture, dye.read.attach(0));
        blit(target);
      };

      const splatPointer = (pointer) => {
        let dx = pointer.deltaX * this.config.SPLAT_FORCE;
        let dy = pointer.deltaY * this.config.SPLAT_FORCE;
        splat(pointer.texcoordX, pointer.texcoordY, dx, dy, pointer.color);
      };

      const clickSplat = (pointer) => {
        const color = generateColor();
        color.r *= 10.0;
        color.g *= 10.0;
        color.b *= 10.0;
        let dx = 10 * (Math.random() - 0.5);
        let dy = 30 * (Math.random() - 0.5);
        splat(pointer.texcoordX, pointer.texcoordY, dx, dy, color);
      };

      const splat = (x, y, dx, dy, color) => {
        splatProgram.bind();
        gl.uniform1i(splatProgram.uniforms.uTarget, velocity.read.attach(0));
        gl.uniform1f(
          splatProgram.uniforms.aspectRatio,
          this.canvas.width / this.canvas.height
        );
        gl.uniform2f(splatProgram.uniforms.point, x, y);
        gl.uniform3f(splatProgram.uniforms.color, dx, dy, 0.0);
        gl.uniform1f(
          splatProgram.uniforms.radius,
          correctRadius(this.config.SPLAT_RADIUS / 100.0)
        );
        blit(velocity.write);
        velocity.swap();

        gl.uniform1i(splatProgram.uniforms.uTarget, dye.read.attach(0));
        gl.uniform3f(splatProgram.uniforms.color, color.r, color.g, color.b);
        blit(dye.write);
        dye.swap();
      };

      const correctRadius = (radius) => {
        let aspectRatio = this.canvas.width / this.canvas.height;
        if (aspectRatio > 1) radius *= aspectRatio;
        return radius;
      };

      const updatePointerDownData = (pointer, id, posX, posY) => {
        pointer.id = id;
        pointer.down = true;
        pointer.moved = false;
        pointer.texcoordX = posX / this.canvas.width;
        pointer.texcoordY = 1.0 - posY / this.canvas.height;
        pointer.prevTexcoordX = pointer.texcoordX;
        pointer.prevTexcoordY = pointer.texcoordY;
        pointer.deltaX = 0;
        pointer.deltaY = 0;
        pointer.color = generateColor();
      };

      const updatePointerMoveData = (pointer, posX, posY, color) => {
        pointer.prevTexcoordX = pointer.texcoordX;
        pointer.prevTexcoordY = pointer.texcoordY;
        pointer.texcoordX = posX / this.canvas.width;
        pointer.texcoordY = 1.0 - posY / this.canvas.height;
        pointer.deltaX = correctDeltaX(
          pointer.texcoordX - pointer.prevTexcoordX
        );
        pointer.deltaY = correctDeltaY(
          pointer.texcoordY - pointer.prevTexcoordY
        );
        pointer.moved =
          Math.abs(pointer.deltaX) > 0 || Math.abs(pointer.deltaY) > 0;
        pointer.color = color;
      };

      const updatePointerUpData = (pointer) => {
        pointer.down = false;
      };

      const correctDeltaX = (delta) => {
        let aspectRatio = this.canvas.width / this.canvas.height;
        if (aspectRatio < 1) delta *= aspectRatio;
        return delta;
      };

      const correctDeltaY = (delta) => {
        let aspectRatio = this.canvas.width / this.canvas.height;
        if (aspectRatio > 1) delta /= aspectRatio;
        return delta;
      };

      const generateColor = () => {
        let c = HSVtoRGB(Math.random(), 1.0, 1.0);
        c.r *= 0.15;
        c.g *= 0.15;
        c.b *= 0.15;
        return c;
      };

      const HSVtoRGB = (h, s, v) => {
        let r, g, b, i, f, p, q, t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
          case 0:
            r = v;
            g = t;
            b = p;
            break;
          case 1:
            r = q;
            g = v;
            b = p;
            break;
          case 2:
            r = p;
            g = v;
            b = t;
            break;
          case 3:
            r = p;
            g = q;
            b = v;
            break;
          case 4:
            r = t;
            g = p;
            b = v;
            break;
          case 5:
            r = v;
            g = p;
            b = q;
            break;
          default:
            break;
        }
        return { r, g, b };
      };

      const wrap = (value, min, max) => {
        const range = max - min;
        if (range === 0) return min;
        return ((value - min) % range) + min;
      };

      const scaleByPixelRatio = (input) => {
        const pixelRatio = window.devicePixelRatio || 1;
        return Math.floor(input * pixelRatio);
      };

      window.addEventListener("mousedown", (e) => {
        let pointer = pointers[0];
        let posX = scaleByPixelRatio(e.clientX);
        let posY = scaleByPixelRatio(e.clientY);
        updatePointerDownData(pointer, -1, posX, posY);
        clickSplat(pointer);
      });

      document.body.addEventListener(
        "mousemove",
        function handleFirstMouseMove(e) {
          let pointer = pointers[0];
          let posX = scaleByPixelRatio(e.clientX);
          let posY = scaleByPixelRatio(e.clientY);
          let color = generateColor();
          updateFrame(); // start animation loop
          updatePointerMoveData(pointer, posX, posY, color);
          document.body.removeEventListener("mousemove", handleFirstMouseMove);
        }
      );

      window.addEventListener("mousemove", (e) => {
        let pointer = pointers[0];
        let posX = scaleByPixelRatio(e.clientX);
        let posY = scaleByPixelRatio(e.clientY);
        let color = pointer.color;
        updatePointerMoveData(pointer, posX, posY, color);
      });

      document.body.addEventListener(
        "touchstart",
        function handleFirstTouchStart(e) {
          const touches = e.targetTouches;
          let pointer = pointers[0];
          for (let i = 0; i < touches.length; i++) {
            let posX = scaleByPixelRatio(touches[i].clientX);
            let posY = scaleByPixelRatio(touches[i].clientY);
            updateFrame(); // start animation loop
            updatePointerDownData(pointer, touches[i].identifier, posX, posY);
          }
          document.body.removeEventListener(
            "touchstart",
            handleFirstTouchStart
          );
        }
      );

      window.addEventListener("touchstart", (e) => {
        const touches = e.targetTouches;
        let pointer = pointers[0];
        for (let i = 0; i < touches.length; i++) {
          let posX = scaleByPixelRatio(touches[i].clientX);
          let posY = scaleByPixelRatio(touches[i].clientY);
          updatePointerDownData(pointer, touches[i].identifier, posX, posY);
        }
      });

      window.addEventListener(
        "touchmove",
        (e) => {
          const touches = e.targetTouches;
          let pointer = pointers[0];
          for (let i = 0; i < touches.length; i++) {
            let posX = scaleByPixelRatio(touches[i].clientX);
            let posY = scaleByPixelRatio(touches[i].clientY);
            updatePointerMoveData(pointer, posX, posY, pointer.color);
          }
        },
        false
      );

      window.addEventListener("touchend", (e) => {
        const touches = e.changedTouches;
        let pointer = pointers[0];
        for (let i = 0; i < touches.length; i++) {
          updatePointerUpData(pointer);
        }
      });

      updateFrame();
    }
  }

  customElements.define("splash-cursor", SplashCursor);
</script>
